// ServiceCases tests traffic from different namespaces to other services
func serviceCases(sourceApp *EchoDeployments, apps map[string]*EchoDeployments) []TrafficTestCase {
	cases := []TrafficTestCase{}
	for _, dest := range apps {
		cases = append(cases, TrafficTestCase{
			name: fmt.Sprintf("call_http_to_%s", dest.EchoPod.Config().Service),
			call: sourceApp.EchoPod.CallOrFail,
			opts: echo.CallOptions{
				To: dest.EchoPod,
				Port: echo.Port{
					Name: "http",
				},
				Check: check.OK(),
			},
		})
		if len(dest.EchoPod.Addresses()) > 1 {
			cases = append(cases, TrafficTestCase{
				name: fmt.Sprintf("call_http_to_%s", dest.EchoPod.Addresses()[1]),
				call: sourceApp.EchoPod.CallOrFail,
				opts: echo.CallOptions{
					To:      dest.EchoPod,
					Address: dest.EchoPod.Addresses()[1],
					Port: echo.Port{
						Name: "http",
					},
					Check: check.OK(),
				},
			})
		}
	}

	return cases
}

func ExpectString(got, expected, help string) error {
	if got != expected {
		return fmt.Errorf("got unexpected %v: got %q, wanted %q", help, got, expected)
	}
	return nil
}

func AlmostEquals(a, b, precision int) bool {
	upper := a + precision
	lower := a - precision
	if b < lower || b > upper {
		return false
	}
	return true
}


func ValidateMetric(t framework.TestContext, cluster cluster.Cluster, prometheus prometheus.Instance, query prometheus.Query, want float64) {
	t.Helper()
	err := retry.UntilSuccess(func() error {
		got, err := prometheus.QuerySum(cluster, query)
		t.Logf("%s: %f", query.Metric, got)
		if err != nil {
			return err
		}
		if got != want {
			return fmt.Errorf("bad metric value: got %f, want at least %f", got, want)
		}
		return nil
	}, retry.Delay(time.Second), retry.Timeout(time.Second*20))
	if err != nil {
		PromDiff(t, prometheus, cluster, query)
		t.Fatal(err)
	}
}

func PromDiff(t test.Failer, prom prometheus.Instance, cluster cluster.Cluster, query prometheus.Query) {
	t.Helper()
	unlabelled := prometheus.Query{Metric: query.Metric}
	v, _ := prom.Query(cluster, unlabelled)
	if v == nil {
		t.Logf("no metrics found for %v", unlabelled)
		return
	}
	switch v.Type() {
	case model.ValVector:
		value := v.(model.Vector)
		var allMismatches []map[string]string
		full := []model.Metric{}
		for _, s := range value {
			misMatched := map[string]string{}
			for k, want := range query.Labels {
				got := string(s.Metric[model.LabelName(k)])
				if want != got {
					misMatched[k] = got
				}
			}
			if len(misMatched) == 0 {
				continue
			}
			allMismatches = append(allMismatches, misMatched)
			full = append(full, s.Metric)
		}
		if len(allMismatches) == 0 {
			t.Logf("no diff found")
			return
		}
		t.Logf("query %q returned %v series, but none matched our query exactly.", query.Metric, len(value))
		t.Logf("Original query: %v", query.String())
		for i, m := range allMismatches {
			t.Logf("Series %d (source: %v/%v)", i, full[i]["namespace"], full[i]["pod"])
			missing := []string{}
			for k, v := range m {
				if v == "" {
					missing = append(missing, k)
				} else {
					t.Logf("  for label %q, wanted %q but got %q", k, query.Labels[k], v)
				}
			}
			if len(missing) > 0 {
				t.Logf("  missing labels: %v", missing)
			}
		}

	default:
		t.Fatalf("PromDiff expects Vector, got %v", v.Type())

	}
}

RUN TRAFFIC TESTS:
for _, sourceApp := range apps {
		cases := serviceCases(sourceApp, apps)
		ctx.NewSubTest(fmt.Sprintf("Reachability_from_%s", sourceApp.Namespace.Name())).
			Run(func(ctx framework.TestContext) {
				for _, tt := range cases {
					tt.Run(ctx, sourceApp.Namespace.Name())
				}
			})
	}




	// Multiple calls. Cannot be used with call/opts
	children []TrafficCall


RUN FUNCTION:
if c.call != nil && len(c.children) > 0 {
			ctx.Fatal("TrafficTestCase: must not specify both call and children")
		}

for _, child := range c.children {
			ctx.NewSubTest(child.name).Run(func(ctx framework.TestContext) {
				child.call(ctx, child.opts, retryOptions...)
			})
		}